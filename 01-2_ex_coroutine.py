"""
1) async def : 코루틴을 정의하는 함수
2) await : 코루틴 내에서 다른 비동기 작업을 호출할 때 사용됩니다. 이때 호출한 작업이 완료될 때까지 대기하지만, 다른 작업이 이 시점에 실행될 수 있음.
3) asyncio.run() : 코루틴을 실행하기 위한 함수, 비동기 이벤트 루프를 실행하고, 코루틴을 처리합니다
4) asyncio.gather() : 여러 코루틴을 동시에 실행할 수 있는 함수, 작업이 병렬로 처리, 각 작업이 독립적으로 실행되며, 대기 시간동안 다른 작업들이 진행됩니다.

장점:
1. 비동기 작업 처리 효율성: 입출력 작업에서 발생하는 대기 시간을 제거, 다른 작업을 처리할 수 있어 CPU 사용률을 극대화할 수 있음
2. 동시성 프로그래밍의 간결성: 코루틴은 멀티스레드나 멀티프로세싱을 사용하지 않고도 동시성 처리를 가능하게 함, 이는 스레드와 관련된 동기화 문제나 잠금(Lock) 문제를 피할 수 있어 코드를 간결하게 유지
3. 코드 가독성 : 비동기 작업을 구현하는 다른 방식들(예: 콜백, 스레드)와 비교했을 때, 동기 함수처럼 읽히기 때문에 가독성이 좋음
4. 자원 절약: 스레드 대신 코루틴을 사용하면 스레드를 생성하는 데 드는 메모리와 리소스를 절약할 수 있음. 코루틴은 함수 호출 스택을 저장하는 데 필요한 메모리만 차지하므로, 수천 개의 코루틴을 생성해도 성능에 큰 영향을 미치지 않음

단점: 
1. CPU 바운드 작업에 부적합: CPU연산에 대해서는 도움x => 멀티스레딩, 멀티프로세싱이 더 적합함.
2. 디버깅 복잡성 : 동기 프로그래밍보다 훨씬 복잡할 수 있음
3. 코드 복잡성 증가 가능성: 여러 코루틴이 동시에 실행될 때, 경합 상태(race condition), 데드락(deadlock) 등  동시성 관련 문제가 발생할 수 있음
4. 외부 라이브러리 의존성: 라이브러리나 API가 비동기 코루틴을 지원하지 않을 수 있음. 비동기 코드를 작성할 때는 비동기 라이브러리가 필요하며, 동기적 라이브러리와 혼용하면 성능이 떨어지거나 복잡해질 수 있음

활용예시: 웹 서버, 네트워크 어플리케이션, 크롤러, 파일/DB 시스템 접근과 같은 I/O 중심 작업에 적합함.
"""
import asyncio

async def task(name, duration):
    print(f"Task {name} 시작")
    await asyncio.sleep(duration) # duration초 동안 비동기 대기
    print(f"Task {name} 종료")
    
async def main():
    # asyncio.gather() : 여러 코루틴을 동시에 실행
    await asyncio.gather(
        task("A", 2),
        task("B", 1),
        task("C", 3)
        )
    
asyncio.run(main())